#include "aribUtil.h"
#include "tsARIBCharset.h"

struct B62Gaiji {
    const char8_t* replacement;
    union {
        char8_t utf8[4];
        uint32_t uint32;
    };
};

struct B24SymbolTable {
    union {
        char8_t utf8[4];
        uint32_t uint32;
    };
};

constexpr B62Gaiji b62GaijiTable[] = {
    {u8"[3D]",       {0xF0, 0x9F, 0x86, 0x9B}},
    {u8"[2nd Scr]",  {0xF0, 0x9F, 0x86, 0x9C}},
    {u8"[2K]",       {0xF0, 0x9F, 0x86, 0x9D}},
    {u8"[4K]",       {0xF0, 0x9F, 0x86, 0x9E}},
    {u8"[8K]",       {0xF0, 0x9F, 0x86, 0x9F}},
    {u8"[5.1]",      {0xF0, 0x9F, 0x86, 0xA0}},
    {u8"[7.1]",      {0xF0, 0x9F, 0x86, 0xA1}},
    {u8"[22.2]",     {0xF0, 0x9F, 0x86, 0xA2}},
    {u8"[60P]",      {0xF0, 0x9F, 0x86, 0xA3}},
    {u8"[120P]",     {0xF0, 0x9F, 0x86, 0xA4}},
    {u8"[d]",        {0xF0, 0x9F, 0x86, 0xA5}},
    {u8"[HC]",       {0xF0, 0x9F, 0x86, 0xA6}},
    {u8"[HDR]",      {0xF0, 0x9F, 0x86, 0xA7}},
    {u8"[Hi-Res]",   {0xF0, 0x9F, 0x86, 0xA8}},
    {u8"[Lossless]", {0xF0, 0x9F, 0x86, 0xA9}},
    {u8"[SHV]",      {0xF0, 0x9F, 0x86, 0xAA}},
    {u8"[UHD]",      {0xF0, 0x9F, 0x86, 0xAB}},
    {u8"[VOD]",      {0xF0, 0x9F, 0x86, 0xAC}},
    {u8"[配]",       {0xF0, 0x9F, 0x88, 0xBB}},
    {u8"令和",       {0xE3, 0x8B, 0xBF, 0}}
};

constexpr B24SymbolTable b24SymbolTable[] = {
    {0xE2, 0x85, 0x90, 0x00}, 
    {0xE2, 0x85, 0x91, 0x00}, 
    {0xE2, 0x85, 0x92, 0x00}, 
    {0xE2, 0x86, 0x89, 0x00}, 
    {0xE2, 0x98, 0x93, 0x00}, 
    {0xE2, 0x9D, 0x97, 0x00}, 
    {0xE3, 0x89, 0x84, 0x00}, 
    {0xE3, 0x89, 0x85, 0x00}, 
    {0xE3, 0x89, 0x86, 0x00}, 
    {0xE3, 0x89, 0x87, 0x00}, 
    {0xE3, 0x89, 0x88, 0x00}, 
    {0xE3, 0x89, 0x89, 0x00}, 
    {0xE2, 0x9B, 0x8C, 0x00}, 
    {0xE2, 0x9B, 0x8D, 0x00}, 
    {0xE2, 0x9B, 0x8F, 0x00}, 
    {0xE2, 0x9B, 0x90, 0x00}, 
    {0xE2, 0x9B, 0x91, 0x00}, 
    {0xE2, 0x9B, 0x92, 0x00}, 
    {0xE2, 0x9B, 0x95, 0x00}, 
    {0xE2, 0x9B, 0x93, 0x00}, 
    {0xE2, 0x9B, 0x94, 0x00}, 
    {0xF0, 0x9F, 0x85, 0xBF}, 
    {0xF0, 0x9F, 0x86, 0x8A}, 
    {0xE2, 0x9B, 0x96, 0x00}, 
    {0xE2, 0x9B, 0x97, 0x00}, 
    {0xE2, 0x9B, 0x98, 0x00}, 
    {0xE2, 0x9B, 0x99, 0x00}, 
    {0xE2, 0x9B, 0x9A, 0x00}, 
    {0xE2, 0x9B, 0x9B, 0x00}, 
    {0xE2, 0x9B, 0x9C, 0x00}, 
    {0xE2, 0x9B, 0x9D, 0x00}, 
    {0xE2, 0x9B, 0x9E, 0x00}, 
    {0xE2, 0x9B, 0x9F, 0x00}, 
    {0xE2, 0x9B, 0xA0, 0x00}, 
    {0xE2, 0x9B, 0xA1, 0x00}, 
    {0xE2, 0xAD, 0x95, 0x00}, 
    {0xE3, 0x89, 0x8A, 0x00}, 
    {0xE3, 0x89, 0x8B, 0x00}, 
    {0xE3, 0x89, 0x8C, 0x00}, 
    {0xE3, 0x89, 0x8D, 0x00}, 
    {0xE3, 0x89, 0x8E, 0x00}, 
    {0xE3, 0x89, 0x8F, 0x00}, 
    {0xF0, 0x9F, 0x85, 0x8A}, 
    {0xF0, 0x9F, 0x85, 0x8C}, 
    {0xF0, 0x9F, 0x84, 0xBF}, 
    {0xF0, 0x9F, 0x85, 0x86}, 
    {0xF0, 0x9F, 0x85, 0x8B}, 
    {0xF0, 0x9F, 0x88, 0x90}, 
    {0xF0, 0x9F, 0x88, 0x91}, 
    {0xF0, 0x9F, 0x88, 0x92}, 
    {0xF0, 0x9F, 0x88, 0x93}, 
    {0xF0, 0x9F, 0x85, 0x82}, 
    {0xF0, 0x9F, 0x88, 0x94}, 
    {0xF0, 0x9F, 0x88, 0x95}, 
    {0xF0, 0x9F, 0x88, 0x96}, 
    {0xF0, 0x9F, 0x85, 0x8D}, 
    {0xF0, 0x9F, 0x84, 0xB1}, 
    {0xF0, 0x9F, 0x84, 0xBD}, 
    {0xE2, 0xAC, 0x9B, 0x00}, 
    {0xE2, 0xAC, 0xA4, 0x00}, 
    {0xF0, 0x9F, 0x88, 0x97}, 
    {0xF0, 0x9F, 0x88, 0x98}, 
    {0xF0, 0x9F, 0x88, 0x99}, 
    {0xF0, 0x9F, 0x88, 0x9A}, 
    {0xF0, 0x9F, 0x88, 0x9B}, 
    {0xE2, 0x9A, 0xBF, 0x00}, 
    {0xF0, 0x9F, 0x88, 0x9C}, 
    {0xF0, 0x9F, 0x88, 0x9D}, 
    {0xF0, 0x9F, 0x88, 0x9E}, 
    {0xF0, 0x9F, 0x88, 0x9F}, 
    {0xF0, 0x9F, 0x88, 0xA0}, 
    {0xF0, 0x9F, 0x88, 0xA1}, 
    {0xF0, 0x9F, 0x88, 0xA2}, 
    {0xF0, 0x9F, 0x88, 0xA3}, 
    {0xF0, 0x9F, 0x88, 0xA4}, 
    {0xF0, 0x9F, 0x88, 0xA5}, 
    {0xF0, 0x9F, 0x85, 0x8E}, 
    {0xF0, 0x9F, 0x88, 0x80}, 
    {0xE2, 0x9B, 0xA3, 0x00}, 
    {0xE2, 0xAD, 0x96, 0x00}, 
    {0xE2, 0xAD, 0x97, 0x00}, 
    {0xE2, 0xAD, 0x98, 0x00}, 
    {0xE2, 0xAD, 0x99, 0x00}, 
    {0xE3, 0x8A, 0x8B, 0x00}, 
    {0xE2, 0x9B, 0xA9, 0x00}, 
    {0xE0, 0xBF, 0x96, 0x00}, 
    {0xE2, 0x9B, 0xAA, 0x00}, 
    {0xE2, 0x9B, 0xAB, 0x00}, 
    {0xE2, 0x9B, 0xAD, 0x00}, 
    {0xE2, 0x9B, 0xAE, 0x00}, 
    {0xE2, 0x9B, 0xAF, 0x00}, 
    {0xE2, 0x9B, 0xB1, 0x00}, 
    {0xE2, 0x9B, 0xB2, 0x00}, 
    {0xE2, 0x9B, 0xB3, 0x00}, 
    {0xE2, 0x9B, 0xB4, 0x00}, 
    {0xE2, 0x9B, 0xB5, 0x00}, 
    {0xF0, 0x9F, 0x85, 0x97}, 
    {0xE2, 0x9B, 0xB6, 0x00}, 
    {0xF0, 0x9F, 0x85, 0x9F}, 
    {0xF0, 0x9F, 0x86, 0x8B}, 
    {0xF0, 0x9F, 0x86, 0x8D}, 
    {0xF0, 0x9F, 0x86, 0x8C}, 
    {0xF0, 0x9F, 0x85, 0xB9}, 
    {0xE2, 0x9B, 0xB7, 0x00}, 
    {0xE2, 0x9B, 0xB8, 0x00}, 
    {0xE2, 0x9B, 0xB9, 0x00}, 
    {0xE2, 0x9B, 0xBA, 0x00}, 
    {0xF0, 0x9F, 0x85, 0xBB}, 
    {0xE2, 0x9B, 0xBB, 0x00}, 
    {0xE2, 0x9B, 0xBC, 0x00}, 
    {0xE2, 0x9B, 0xBD, 0x00}, 
    {0xE2, 0x9B, 0xBE, 0x00}, 
    {0xF0, 0x9F, 0x85, 0xBC}, 
    {0xE2, 0x9B, 0xBF, 0x00}, 
    {0xF0, 0x9F, 0x84, 0x80}, 
    {0xF0, 0x9F, 0x84, 0x81}, 
    {0xF0, 0x9F, 0x84, 0x82}, 
    {0xF0, 0x9F, 0x84, 0x83}, 
    {0xF0, 0x9F, 0x84, 0x84}, 
    {0xF0, 0x9F, 0x84, 0x85}, 
    {0xF0, 0x9F, 0x84, 0x86}, 
    {0xF0, 0x9F, 0x84, 0x87}, 
    {0xF0, 0x9F, 0x84, 0x88}, 
    {0xF0, 0x9F, 0x84, 0x89}, 
    {0xF0, 0x9F, 0x84, 0x8A}, 
    {0xE2, 0x9F, 0x90, 0x00}, 
    {0xF0, 0x9F, 0x84, 0xAD}, 
    {0xF0, 0x9F, 0x86, 0x90}, 
    {0xF0, 0x9F, 0x88, 0xA6}, 
    {0xE2, 0x9A, 0xBE, 0x00}, 
    {0xF0, 0x9F, 0x89, 0x80}, 
    {0xF0, 0x9F, 0x89, 0x81}, 
    {0xF0, 0x9F, 0x89, 0x82}, 
    {0xF0, 0x9F, 0x89, 0x83}, 
    {0xF0, 0x9F, 0x89, 0x84}, 
    {0xF0, 0x9F, 0x89, 0x85}, 
    {0xF0, 0x9F, 0x89, 0x86}, 
    {0xF0, 0x9F, 0x89, 0x87}, 
    {0xF0, 0x9F, 0x89, 0x88}, 
    {0xF0, 0x9F, 0x84, 0xAA}, 
    {0xF0, 0x9F, 0x88, 0xA7}, 
    {0xF0, 0x9F, 0x88, 0xA8}, 
    {0xF0, 0x9F, 0x88, 0xA9}, 
    {0xF0, 0x9F, 0x88, 0xAA}, 
    {0xF0, 0x9F, 0x88, 0xAB}, 
    {0xF0, 0x9F, 0x88, 0xAC}, 
    {0xF0, 0x9F, 0x88, 0xAD}, 
    {0xF0, 0x9F, 0x88, 0xAE}, 
    {0xF0, 0x9F, 0x88, 0xAF}, 
    {0xF0, 0x9F, 0x88, 0xB0}, 
    {0xF0, 0x9F, 0x88, 0xB1}, 
    {0xE2, 0x85, 0x9B, 0x00}, 
    {0xE2, 0x9A, 0x9E, 0x00}, 
    {0xE2, 0x9A, 0x9F, 0x00}, 
};

namespace {

void replaceSequence(std::string& str, const char* sequence, size_t sequencelen, const char* replacement) {
    std::size_t pos = 0;

    while ((pos = str.find(sequence, pos)) != std::string::npos) {
        str.replace(pos, sequencelen, replacement);
        pos += 1;
    }
}
    
void convertB62Gaiji(std::string& str) {
    for (auto gaiji : b62GaijiTable) {
        if (gaiji.utf8[3] == 0) {
            replaceSequence(str, reinterpret_cast<const char*>(gaiji.utf8), 3, reinterpret_cast<const char*>(gaiji.replacement));
        }
        else {
            replaceSequence(str, reinterpret_cast<const char*>(gaiji.utf8), 4, reinterpret_cast<const char*>(gaiji.replacement));
        }
    }
}

}

const ts::ByteBlock aribEncode(const std::string& input) {
    std::string converted = input;
    
    std::vector<std::pair<int, std::string>> split;
    int type = -1; // 0: normal, 1: B24 symbol, 2: B64 gaiji
    
    int i = 0;
    while (i < converted.size()) {
        bool find = false;
        if (converted.size() - i >= 4) {
            uint32_t uint32 = *(uint32_t*)(converted.data() + i);

            for (auto gaiji : b24SymbolTable) {
                if (uint32 == gaiji.uint32) {
                    if (type == 1) {
                        split.back().second.append((char*)gaiji.utf8, 4);
                    }
                    else {
                        split.push_back(std::pair<int, std::string>(1, std::string{(char*)gaiji.utf8, 4}));
                    }
                    type = 1;
                    i+=4;
                    find = true;
                    break;
                }
            }
            if (find) {
                continue;
            }

            for (auto gaiji : b62GaijiTable) {
                if (uint32 == gaiji.uint32) {
                    if (type == 2) {
                        split.back().second.append((char*)gaiji.replacement);
                    }
                    else {
                        split.push_back(std::pair<int, std::string>(2, std::string{(char*)gaiji.replacement}));
                    }
                    type = 2;
                    i+=4;
                    find = true;
                    break;
                }
            }
            if (find) {
                continue;
            }
        }

        if (converted.size() - i >= 3) {
            uint32_t uint32 = *(uint32_t*)(converted.data() + i) & 0x00FFFFFF;

            for (auto gaiji : b24SymbolTable) {
                if (uint32 == gaiji.uint32) {
                    if (type == 1) {
                        split.back().second.append((char*)gaiji.utf8);
                    }
                    else {
                        split.push_back(std::pair<int, std::string>(1, std::string{(char*)gaiji.utf8, 3}));
                    }
                    type = 1;
                    i+=3;
                    find = true;
                    break;
                }
            }
            if (find) {
                continue;
            }

            for (auto gaiji : b62GaijiTable) {
                if (uint32 == gaiji.uint32) {
                    if (type == 2) {
                        split.back().second.append((char*)gaiji.replacement);
                    }
                    else {
                        split.push_back(std::pair<int, std::string>(2, std::string{(char*)gaiji.replacement}));
                    }
                    type = 2;
                    i+=3;
                    find = true;
                    break;
                }
            }
            if (find) {
                continue;
            }
        }
        
        if (converted.size() - i >= 2) {
            uint32_t uint32 = *(uint32_t*)(converted.data() + i) & 0x0000FFFF;

            for (auto gaiji : b24SymbolTable) {
                if (uint32 == gaiji.uint32) {
                    if (type == 1) {
                        split.back().second.append((char*)gaiji.utf8);
                    }
                    else {
                        split.push_back(std::pair<int, std::string>(1, std::string{(char*)gaiji.utf8, 2}));
                    }
                    type = 1;
                    i+=2;
                    find = true;
                    break;
                }
            }
            if (find) {
                continue;
            }

            for (auto gaiji : b62GaijiTable) {
                if (uint32 == gaiji.uint32) {
                    if (type == 2) {
                        split.back().second.append((char*)gaiji.replacement);
                    }
                    else {
                        split.push_back(std::pair<int, std::string>(2, std::string{(char*)gaiji.replacement}));
                    }
                    type = 2;
                    i+=2;
                    find = true;
                    break;
                }
            }
            if (find) {
                continue;
            }
        }

        if (type == 0) {
            split.back().second.push_back(converted[i]);
        }
        else {
            split.push_back(std::pair<int, std::string>(0, std::string{converted[i]}));
        }

        type = 0;
        i+=1;
        continue;
    }
    
    ts::ByteBlock output;

    bool symbol = false;
    for(const auto& item : split) {
        ts::UString text = ts::UString::FromUTF8(item.second);

        auto aribBlock = ts::ARIBCharset2::B24.encoded(text);
        std::string aribString((char*)aribBlock.data(), aribBlock.size());
        
        if (item.first == 0 || item.first == 2) {
            if (symbol) {
                output.push_back(0x1B);
                output.push_back(0x24);
                output.push_back(0x39);
                symbol = false;
            }
        }
        else if (item.first == 1) {
            output.push_back(0x8A);
            output.push_back(0x1B);
            output.push_back(0x24);
            output.push_back(0x3B);
            output.push_back(0x0F);
            symbol = true;
        }

        output.insert(output.end(), aribBlock.begin(), aribBlock.end());
    }
    
    return output;
}

const ts::ByteBlock aribEncode(const char* input, size_t size) {
    return aribEncode(std::string{ input, size });
}
